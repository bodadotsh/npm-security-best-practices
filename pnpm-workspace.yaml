# https://pnpm.io/settings

###############################################################################
# pnpm-workspace.yaml â€” Enterprise Defaults (Security-first, ES2024+, pnpm)
#
# Legend used below:
#  - âœ… recommended default
#  - ğŸ” securityâ€‘critical
#  - âš ï¸ situational/conditional
#  - âŒ avoid/antiâ€‘pattern
#  - ğŸ¢ workspace/monorepoâ€‘only
#  - ğŸ“¦ libraryâ€‘specific
#  - ğŸš€ application/serviceâ€‘specific
###############################################################################

########################################
# Security posture
# Why: Reduce supplyâ€‘chain risk, enforce correctness early, and require
#      explicit decisions for peers and scripts. These settings fail fast in CI
#      and local dev, preventing unsafe or accidental changes.
########################################

# minimumReleaseAge (ğŸ”) â€” delay adoption of freshly published versions to
# reduce exposure to compromised releases. Enterprise baseline: 24h.
# Example: A malicious subdependency published at 12:00 will not be installed
#          during your 14:00 CI run; it becomes eligible after 24h.
minimumReleaseAge: 1440            # ğŸ” âœ… 24h delay to avoid fresh hijacks

# engineStrict (ğŸ”) â€” block installs if a dependency declares engines incompatible
# with the workspace Node. Prevents adding deps that wonâ€™t run on your baseline.
# Example: A dep requires node ">=22"; with nodeVersion: 22.7.0 it installs, but
#          with nodeVersion: 20 it fails immediately.
engineStrict: true                 # ğŸ” âœ… enforce engines during dependency install

# strictPeerDependencies (ğŸ”) â€” fail on missing/invalid peers to surface runtime
# issues (e.g., multiple Reacts) at install time.
# Example: A plugin declares peer eslint@^9; if not installed or wrong range,
#          install fails until you add the correct peer.
strictPeerDependencies: true       # ğŸ” âœ… fail on missing/invalid peers

# strictDepBuilds (ğŸ”) â€” block unreviewed install scripts (pre/install/postinstall)
# of transitive dependencies by default.
# Example: If a transitive adds a new postinstall, install fails unless itâ€™s
#          approved via onlyBuiltDependencies or allowâ€‘list file.
strictDepBuilds: true              # ğŸ” âœ… fail on unreviewed postinstall scripts

# autoInstallPeers (ğŸ”) â€” do not autoâ€‘add peers. Forces explicit peer decisions
# in your manifests; avoids silent dependency drift.
# Example: A library peer on react-dom wonâ€™t be autoâ€‘installed; you must list it
#          explicitly where required.
autoInstallPeers: false            # ğŸ” âœ… require explicit peer decisions (esp. for libs)

########################################
# Node & package manager control
# Why: Pin runtime and package manager for deterministic behavior in CI/dev.
# Notes: packageManagerStrictVersion affects only this repoâ€™s contributors/CI;
#        it does NOT impact consumers of your published packages.
########################################

# useNodeVersion â€” exact Node runtime used by pnpm run/exec in this workspace.
# Example: Ensures tests/builds run on Node 22.7.0 regardless of developerâ€™s
#          globally installed Node.
useNodeVersion: 22.14.0             # âœ… pin runtime used by pnpm run/exec

# nodeVersion â€” baseline for validating dependency engines. Blocks adding deps
# that donâ€™t support your runtime.
# Example: Prevents adding a dep that only supports Node >=24 when baseline is 22.
nodeVersion: 22.14.0                # âœ… check new deps against node engines

# packageManagerStrict â€” require pnpm (not npm/yarn) for all workspace tasks.
# Example: Running npm install will be rejected to avoid lockfile/tool drift.
packageManagerStrict: true         # âœ… enforce pnpm usage

# packageManagerStrictVersion (ğŸ”) â€” require the EXACT pnpm version declared in
# package.json "packageManager". Affects only contributors/CI in this repo.
# Example: Repo pins pnpm@9.12.0; a contributor with pnpm@10 will autoâ€‘switch
#          (with managePackageManagerVersions) or be blocked until matching.
packageManagerStrictVersion: true  # ğŸ” âœ… exact pnpm version match (repoâ€‘local)

# managePackageManagerVersions â€” autoâ€‘download & use the pinned pnpm version
# from package.json (Corepackâ€‘like behavior) to reduce friction.
# Example: Developer has pnpm@10 installed; CLI fetches pnpm@9.12.0 on demand.
managePackageManagerVersions: true # âœ… auto-manage pnpm version in packageManager

########################################
# Resolution & lockfile
# Why: Deterministic, headless installs; safer resolution strategy; less churn.
########################################

# preferFrozenLockfile (ğŸ”) â€” skip resolution when lockfile satisfies deps; fail
# if changes would be needed. Great for CI and reproducible builds.
# Example: pnpm install in CI fails if package.json changed but lockfile wasnâ€™t
#          updated in the PR.
preferFrozenLockfile: true         # ğŸ” âœ… headless, deterministic installs

# resolutionMode: time-based (ğŸ”) â€” direct deps lowest; subdeps pinned to
# versions not newer than the last direct dep publish time (reduces hijack risk).
# Example: Upgrading eslint updates its subdeps in a bounded, timeâ€‘coherent set.
resolutionMode: time-based         # ğŸ” âœ… safer subdep updates (less hijacks)

# registrySupportsTimeField â€” set true if your registry/mirror provides the
# "time" field in abbreviated metadata (e.g., Verdaccio â‰¥ 5.15.1) to speed up
# timeâ€‘based resolution.
registrySupportsTimeField: false   # âš ï¸ set true if Verdaccio â‰¥5.15.1

# sharedWorkspaceLockfile (ğŸ¢) â€” single lockfile for the monorepo; faster installs
# and smaller diffs; still preserves pnpmâ€™s strictness at project boundaries.
sharedWorkspaceLockfile: true      # ğŸ¢ âœ… single lockfile across the monorepo

########################################
# Workspace linking
# Why: Optimize monorepo dev experience; prefer local packages; control saved
# spec format for clarity and exact pinning.
########################################

# linkWorkspacePackages (ğŸ¢) â€” link local packages instead of downloading.
# Example: Changes in a local package immediately reflect in dependents.
linkWorkspacePackages: true        # ğŸ¢ âœ… local linking (symlinks) for speed

# preferWorkspacePackages (ğŸ¢) â€” prefer local over registry when ranges match.
# Example: Even if registry has a newer version, the local workspace package is
#          used for development.
preferWorkspacePackages: true      # ğŸ¢ âœ… prefer local over registry

# saveWorkspaceProtocol (ğŸ¢) â€” save dependencies as workspace:* in package.json.
# Example: "ui-kit": "workspace:^" shows intent clearly in manifests.
saveWorkspaceProtocol: true        # ğŸ¢ âœ… write workspace:* specs

# savePrefix (ğŸ¢) â€” how to prefix saved versions; '' pins exact.
# Example: Adds "workspace:*" plus exact pinning where applicable.
savePrefix: ''                     # ğŸ¢ âœ… pin exact within workspace

########################################
# Hoisting / Node linker
# Why: Favor pnpmâ€™s isolated linker for correctness; allow targeted hoisting for
# legacy tooling that resolves incorrectly. Avoid exposing phantom deps to app code.
########################################

# nodeLinker â€” choose dependency layout. "isolated" = pnpm symlinked virtual store.
# Example: Use isolated for strictness and compatibility with most tooling.
nodeLinker: isolated               # âœ… stable, strict node_modules with symlinks

# hoist â€” enable hoisting into hidden .pnpm/node_modules to help flawed tools.
# Example: Some linters/loaders expect transitive deps to be findable.
hoist: true                        # âš ï¸ allow controlled hoisting for flawed tools

# hoistPattern â€” restrict which packages to hoist (minimize surface).
# Example: Hoist only ESLint and Babel ecosystems.
hoistPattern:                      # âš ï¸ only hoist known phantom-dep offenders
  - "*eslint*"
  - "*babel*"

# publicHoistPattern â€” hoist to the project root node_modules (visible to app
# code). Keep empty to avoid phantom access.
publicHoistPattern: []             # ğŸ” avoid exposing phantom deps to app code

# shamefullyHoist â€” blanket public hoist (behaves like npm/yarn classic).
# Avoid to preserve correctness and least privilege.
shamefullyHoist: false             # ğŸ” âŒ never blanket-hoist

########################################
# Modules & store
# Why: Stable virtual store placement; performance via CoW; integrity checks.
########################################

# virtualStoreDir â€” where the virtual store lives relative to project root.
# Example: ".pnpm" shortens stack traces and avoids deep paths.
virtualStoreDir: .pnpm             # âœ… shorter paths, cleaner stack traces

# virtualStoreDirMaxLength â€” cap store path segments to avoid Windows path issues.
virtualStoreDirMaxLength: 120      # âœ… keep windows-safe length

# packageImportMethod â€” prefer clone/copyâ€‘onâ€‘write when supported; fall back to copy.
# Example: On Btrfs/APFS, CoW speeds up installs and avoids store mutations.
packageImportMethod: clone-or-copy # âœ… safe across filesystems (CoW when possible)

# modulesCacheMaxAge â€” keep orphaned modules cache to speed branch switches/downgrades.
modulesCacheMaxAge: 10080          # ğŸ§ª reuse orphan cache for faster branch switches

# dlxCacheMaxAge â€” cache @pnpm/dlx executions for faster tooling runs.
dlxCacheMaxAge: 1440               # ğŸ§ª speed up pnpm dlx reuse

# verifyStoreIntegrity (ğŸ”) â€” checksum verify before linking from store to project.
verifyStoreIntegrity: true         # ğŸ” âœ… content check before linking

# storeDir â€” global contentâ€‘addressable store location. Keep on same disk as project
# for hardlink performance.
# storeDir: ${XDG_DATA_HOME:-${HOME}/.local/share}/pnpm/store # âœ… predictable

########################################
# Build script security
# Why: Minimize risk from transitive install scripts; apply least privilege and
# explicit allowâ€‘listing.
########################################

# onlyBuiltDependenciesFile (ğŸ”) â€” JSON allowâ€‘list of packages permitted to run
# install scripts. Everything else is blocked.
# Example file (JSON array): ["fsevents", "@some/native"]
# onlyBuiltDependenciesFile: node_modules/.pnpm-config/@pnpm/trusted-deps/allow.json # ğŸ” âœ… strict allow-list

# neverBuiltDependencies (ğŸ”) â€” skip building listed packages entirely.
# Example: fsevents is macOSâ€‘only; safe to ignore on other platforms.
neverBuiltDependencies:            # ğŸ” block native/platform dependent builds unless needed
  - fsevents

# ignoredBuiltDependencies (ğŸ”) â€” dependencies that should not run build scripts
# even if present (e.g., prebuilt binaries).
# Example: esbuild ships prebuilt; skip building.
ignoredBuiltDependencies:          # ğŸ” skip building deps known to be prebuilt
  - esbuild

# dangerouslyAllowAllBuilds (ğŸ”) â€” never enable in enterprise; allows every script.
dangerouslyAllowAllBuilds: false   # ğŸ” âŒ never blanket-allow all scripts

# enablePrePostScripts (ğŸ”) â€” disable automatic pre/post script hooks; run explicitly
# in CI or via targeted scripts.
enablePrePostScripts: false        # ğŸ” prefer explicit pnpm run pre/post if needed

# verifyDepsBeforeRun (ğŸ”) â€” enforce dependency freshness before running scripts.
# Values: install | warn | prompt | error | false
# Example: error prevents running tests if node_modules is stale.
verifyDepsBeforeRun: error         # ğŸ” âœ… forbid running scripts on stale node_modules

########################################
# Peer dependency resolution
# Why: Ensure single, compatible peer versions and reduce duplication noise.
########################################

# resolvePeersFromWorkspaceRoot (ğŸ¢) â€” resolve peers from root deps; use one set
# of peer versions across the monorepo.
resolvePeersFromWorkspaceRoot: true # ğŸ¢ âœ… single source of truth for peers

# dedupePeerDependents â€” deduplicate packages post peer resolution when possible.
# Example: Both projects share webpack with the same resolved peers â†’ one instance.
dedupePeerDependents: true          # âœ… dedupe when peers are compatible

# peerDependencyRules â€” control warnings and allowed version ranges for peers.
# Example (commented):
# peerDependencyRules:
#   ignoreMissing:
#     - "@babel/*"
#   allowedVersions:
#     react: "18"
#   allowAny: []
peerDependencyRules:
  ignoreMissing: []                 # ğŸ” avoid suppressing warnings unless vetted
  allowedVersions: []                 # ğŸ” set narrowly if needed
  allowAny: []                      # ğŸ” avoid blanket allow

########################################
# Overrides & extensions
# Why: Pin or remove risky transitive deps; patch broken manifests via extensions.
########################################

# overrides (ğŸ”) â€” force specific versions or remove transitive deps.
# Examples (commented):
# overrides:
#   "minimist": "1.2.8"          # pin fixed version
#   "foo@1.0.0>bar": "-"         # remove unused optional dep
overrides: {}                      # ğŸ” pin/bisect transitive deps or remove with "-"

# packageExtensions (ğŸ”) â€” add missing deps/peers to thirdâ€‘party packages.
# Example (commented):
# packageExtensions:
#   react-redux:
#     peerDependencies:
#       react-dom: "*"
packageExtensions: {}              # ğŸ” patch missing peers of third-party packages

# allowedDeprecatedVersions (ğŸ”) â€” mute deprecation warnings intentionally.
allowedDeprecatedVersions: {}      # ğŸ” whitelist intentionally if necessary

########################################
# Catalog governance
# Why: Centralize approved versions via catalog; keep catalog clean over time.
########################################

# catalogMode â€” add behavior for dependency catalog usage during pnpm add.
#   strict: only allow catalog versions; prefer: prefer catalog; manual: default.
catalogMode: strict                # ğŸ¢ ğŸ” version catalog is the source of truth

# cleanupUnusedCatalogs â€” remove unused catalog entries automatically on install.
cleanupUnusedCatalogs: true        # ğŸ¢ âœ… remove stale catalog entries

########################################
# CI ergonomics
# Why: Faster, safer CI runs; enforce required scripts; crossâ€‘platform reliability.
########################################

# ci â€” explicitly mark CI environments (usually autoâ€‘detected); included for clarity.
ci: true                           # âœ… when under CI to optimize defaults

# optimisticRepeatInstall â€” shortâ€‘circuit repeats/noâ€‘op installs.
optimisticRepeatInstall: true      # âœ… fast no-op for repeat installs

# requiredScripts (ğŸ¢) â€” ensure these scripts exist in each package for repoâ€‘wide
# commands (e.g., pnpm -r run build).
requiredScripts:                   # ğŸ¢ enforce available scripts across packages
  - build
  - test

# shellEmulator â€” bashâ€‘like emulator for crossâ€‘platform script portability.
shellEmulator: true                # âœ… cross-platform script execution

# includeWorkspaceRoot (ğŸ¢) â€” exclude root from recursive runs to avoid side effects.
includeWorkspaceRoot: false        # ğŸ¢ avoid running recursive scripts at root

# disallowWorkspaceCycles (ğŸ¢) â€” fail install on workspace dependency cycles.
disallowWorkspaceCycles: true      # ğŸ¢ fail on cycles early

########################################
# Optional: branch-based lockfiles in high-conflict repos
# Why: Reduce lockfile merge conflicts by generating perâ€‘branch lockfiles and
# optionally merging them on specific branches.
########################################

# gitBranchLockfile â€” generate pnpm-lock.<branch>.yaml instead of a single lockfile.
# Enable only when you have automation to merge lockfiles back on main/release.
gitBranchLockfile: false           # âš ï¸ enable only with merge automation

# mergeGitBranchLockfilesBranchPattern â€” branches on which lockfiles should be
# merged automatically (pattern list). Keep null when not used.
mergeGitBranchLockfilesBranchPattern: null
